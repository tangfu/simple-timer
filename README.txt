simple-timer
============

a simple timer library, time-wheel and minheap
一个简单的定时器库，分别使用一级时间轮和最小堆实现

===========
1. 【特性】
    * 暂时只采用单粒度时间轮来实现，未来版本会考虑支持多粒度的时间轮\n
    * 未来可能会加入最小堆的实现\n
    * 由于使用了线程读写锁, 并设置了pshared属性，因此线程锁可以在多个进程中使用，使用时必须链接pthread库\n
    * 库使用了SIGRTMAX-2信号，因此使用时不要冲突\n
    * 定时单位是毫秒，因此精确到ms(毫秒)，堆定时器单元精确到s(秒)\n
    * 添加定时器，不限制重复性，完全一样的定时器可以添加也不会被覆盖
    * 由于系统使用了clock_gettime因此使用时必须链接rt库(注意-lrt在-ltimer后面)
    * 提供定时器任务的多种响应方式：直接执行，线程异步执行，发送信号
    * 支持循环定时器和一次性定时器
    * 支持多线程多进程中使用

===========
2. 【使用】
    详见example文件夹

3. 【与内核定时器区别】
    内核定时器timer_list:
	记录绝对时间(jiffers);每一层时间轮转完一圈将会触发上一层时间轮当前定时器列表被重新添加;定时器是否到期只依赖于最底层时间轮;时间轮的转动不需要额外操作;使用自旋锁.
    用户级定时器simple-timer:
	记录间隔时间(即超时时间);定时器一旦被添加到超时前不会被移动;定时器是否到期需要比较定时器圈数值;时间轮的转动需要对每个定时器做一次数学运算;使用互斥锁.

4. 【注意】
    timer_manager_conf中的slot_num和timer_max_num通常情况应该一致。slot_num越大，定时粒度就越小，被单一散列的概率就更大；而timer_max_num远大于slot_num，那么每个时间片上挂接多个节点的概率就更大


